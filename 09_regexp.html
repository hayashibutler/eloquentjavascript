<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Cahpter 9 - Regular Expressions</title>
</head>
<body>
<h4>Chapter 9</h4>
<h2>Regular Expressions</h2>
<blockquote>"Some people, when confronted with a problem, think ‘I know, I’ll use regular expressions.’ Now they have two problems."</blockquote>
<p>-Jamie Zawinski</p>
<blockquote>"Yuan-Ma said, ‘When you cut against the grain of the wood, much strength is needed. When you program against the grain of the problem, much code is needed.’"</blockquote>
<p>-Master Yuan-Ma, The Book of Programming</p>
<img src="/images/chapter_picture_9.jpg">
<p>Programming tools and techniques survive and spread in a chaotic, evolutionary way. It’s not always the pretty or brilliant ones that win but rather the ones that function well enough within the right niche or that happen to be integrated with another successful piece of technology.</p>
<p>In this chapter, I will discuss one such tool, regular expressions. Regular expressions are a way to describe patterns in string data. They form a small, separate language that is part of JavaScript and many other languages and systems.</p>
<p>Regular expressions are both terribly awkward and extremely useful. Their syntax is cryptic, and the programming interface JavaScript provides for them is clumsy. But they are a powerful tool for inspecting and processing strings. Properly understanding regular expressions will make you a more effective programmer.</p>
<h3>Creating a regular expression</h3>
<p>A regular expression is a type of object. It can be either constructed with the RegExp constructor or written as a literal value by enclosing a pattern in forward slash (/) characters.</p>
<pre>let re1 = new RegExp("abc");
let re2 = /abc/;</pre>
<p>Both of those regular expression objects represent the same pattern: an <i>a</i> character followed by a <i>b</i> followed by a <i>c</i>.</p>
<p>When using the RegExp constructor, the pattern is written as a normal string, so the usual rules apply for backslashes.</p>
<p>The second notation, where the pattern appears between slash characters, treats backslashes somewhat differently. First, since a forward slash ends the pattern, we need to put a backslash before any forward slash that we want to be part of the pattern. In addition, backslashes that aren’t part of special character codes (like \n) will be preserved, rather than ignored as they are in strings, and change the meaning of the pattern. Some characters, such as question marks and plus signs, have special meanings in regular expressions and must be preceded by a backslash if they are meant to represent the character itself.</p>
<pre>let eighteenPlus = /eighteen\+/;
</pre>
<h3>Testing for matches</h3>
<p>Regular expression objects have a number of methods. The simplest one is test. If you pass it a string, it will return a Boolean telling you whether the string contains a match of the pattern in the expression.</p>
<pre>console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false</pre>
<p>A regular expression consisting of only nonspecial characters simply represents that sequence of characters. If abc occurs anywhere in the string we are testing against (not just at the start), test will return true.</p>
<h3>Sets of characters</h3>
<p>Finding out whether a string contains abc could just as well be done with a call to indexOf. Regular expressions allow us to express more complicated patterns.</p>
<p>Say we want to match any number. In a regular expression, putting a set of characters between square brackets makes that part of the expression match any of the characters between the brackets.</p>
<p>Both of the following expressions match all strings that contain a digit:</p>
<pre>console.log(/[0123456789]/.test("in 1992"));
// → true
console.log(/[0-9]/.test("in 1992"));
// → true</pre>
<p>Within square brackets, a hyphen (-) between two characters can be used to indicate a range of characters, where the ordering is determined by the character’s Unicode number. Characters 0 to 9 sit right next to each other in this ordering (codes 48 to 57), so [0-9] covers all of them and matches any digit.</p>
<p>A number of common character groups have their own built-in shortcuts. Digits are one of them: \d means the same thing as [0-9].</p>
<p>
\d	Any digit character
\w	An alphanumeric character (“word character”)
\s	Any whitespace character (space, tab, newline, and similar)
\D	A character that is not a digit
\W	A nonalphanumeric character
\S	A nonwhitespace character
.	Any character except for newline</p>
<p>So you could match a date and time format like 01-30-2003 15:20 with the following expression:</p>
<pre>let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test("01-30-2003 15:20"));
// → true
console.log(dateTime.test("30-jan-2003 15:20"));
// → false</pre>
<p>That looks completely awful, doesn’t it? Half of it is backslashes, producing a background noise that makes it hard to spot the actual pattern expressed. We’ll see a slightly improved version of this expression later.</p>
<p>These backslash codes can also be used inside square brackets. For example, [\d.] means any digit or a period character. But the period itself, between square brackets, loses its special meaning. The same goes for other special characters, such as +.</p>
<p>To invert a set of characters—that is, to express that you want to match any character except the ones in the set—you can write a caret (^) character after the opening bracket.</p>
<pre>let notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// → false
console.log(notBinary.test("1100100010200110"));
// → true</pre>
<h3>Repeating parts of a pattern</h3>
<P>We now know how to match a single digit. What if we want to match a whole number—a sequence of one or more digits?</P>
<P>When you put a plus sign (+) after something in a regular expression, it indicates that the element may be repeated more than once. Thus, /\d+/ matches one or more digit characters.</P>
<pre>console.log(/'\d+'/.test("'123'"));
// → true
console.log(/'\d+'/.test("''"));
// → false
console.log(/'\d*'/.test("'123'"));
// → true
console.log(/'\d*'/.test("''"));
// → true</pre>
<p>The star (*) has a similar meaning but also allows the pattern to match zero times. Something with a star after it never prevents a pattern from matching—it’ll just match zero instances if it can’t find any suitable text to match.</p>
<p>A question mark makes a part of a pattern optional, meaning it may occur zero times or one time. In the following example, the u character is allowed to occur, but the pattern also matches when it is missing.</p>
<pre>let neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// → true
console.log(neighbor.test("neighbor"));
// → true</pre>
<p>To indicate that a pattern should occur a precise number of times, use braces. Putting {4} after an element, for example, requires it to occur exactly four times. It is also possible to specify a range this way: {2,4} means the element must occur at least twice and at most four times.</p>
<p>Here is another version of the date and time pattern that allows both single- and double-digit days, months, and hours. It is also slightly easier to decipher.</p>
<pre>let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("1-30-2003 8:45"));
// → true</pre>
<p>You can also specify open-ended ranges when using braces by omitting the number after the comma. So, {5,} means five or more times.</p>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>chap 3 - Function</title>
</head>
<body>
<h4>Chapter 3</h4>
<h2>Functions</h2>
<blockquote>"People think that computer science is the art of geniuses but the actual reality is the opposite, just many people doing things that build on each other, like a wall of mini stones."
-Donald Knuth</blockquote>
<img src="/images/chapter_picture_3.jpg">
<p>Functions are the bread and butter of JavaScript programming. The concept of wrapping a piece of program in a value has many uses. It gives us a way to structure larger programs, to reduce repetition, to associate names with subprograms, and to isolate these subprograms from each other.</p>
<p>The most obvious application of functions is defining new vocabulary. Creating new words in prose is usually bad style. But in programming, it is indispensable.</p>
<p>Typical adult English speakers have some 20,000 words in their vocabulary. Few programming languages come with 20,000 commands built in. And the vocabulary that is available tends to be more precisely defined, and thus less flexible, than in human language. Therefore, we usually have to introduce new concepts to avoid repeating ourselves too much.</p>
<h3>Defining a function</h3>
<p>A function definition is a regular binding where the value of the binding is a function. For example, this code defines <code>square</code> to refer to a function that produces the square of a given number:</p>
<pre>const square = function(x) {
  return x * x;
};

console.log(square(12));
// → 144</pre>
<p>A function is created with an expression that starts with the keyword <code>function</code>. Functions have a set of <i>parameters</i> (in this case, only <code>x</code>) and a <i>body</i>, which contains the statements that are to be executed when the function is called. The function body of a function created this way must always be wrapped in braces, even when it consists of only a single statement.</p>
<p>A function can have multiple parameters or no parameters at all. In the following example, <code>makeNoise</code> does not list any parameter names, whereas <code>power</code> lists two:</p>
<pre>const makeNoise = function() {
  console.log("Pling!");
};

makeNoise();
// → Pling!

const power = function(base, exponent) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};

console.log(power(2, 10));
// → 1024</pre>
<p>Some functions produce a value, such as <code>power</code> and <code>square</code>, and some don’t, such as <code>makeNoise</code>, whose only result is a side effect. A <code>return</code> statement determines the value the function returns. When control comes across such a statement, it immediately jumps out of the current function and gives the returned value to the code that called the function. A <code>return</code> keyword without an expression after it will cause the function to return <code>undefined</code>. Functions that don’t have a return statement at all, such as <code>makeNoise</code>, similarly return <code>undefined</code>.</p>
<p>Parameters to a function behave like regular bindings, but their initial values are given by the <code>caller</code> of the function, not the code in the function itself.</p>
<h3>Bindings and scopes</h3>
<p>Each binding has a <i>scope</i>, which is the part of the program in which the binding is visible. For bindings defined outside of any function or block, the scope is the whole program—you can refer to such bindings wherever you want. These are called <i>global</i>.</p>
<p>But bindings created for function parameters or declared inside a function can be referenced only in that function, so they are known as <i>local</i> bindings. Every time the function is called, new instances of these bindings are created. This provides some isolation between functions—each function call acts in its own little world (its local environment) and can often be understood without knowing a lot about what’s going on in the global environment.</p>
<p>Bindings declared with <code>let</code> and <code>const</code> are in fact local to the <i>block</i> that they are declared in, so if you create one of those inside of a loop, the code before and after the loop cannot “see” it. In pre-2015 JavaScript, only functions created new scopes, so old-style bindings, created with the <code>var</code> keyword, are visible throughout the whole function that they appear in—or throughout the global scope, if they are not in a function.</p>
<pre>let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
  // → 60
}
// y is not visible here
console.log(x + z);
// → 40</pre>
<h3>Nested scope</h3>
<p>JavaScript distinguishes not just <i>global</i> and <i>local</i> bindings. Blocks and functions can be created inside other blocks and functions, producing multiple degrees of locality.</p>
<p>For example, this function—which outputs the ingredients needed to make a batch of hummus—has another function inside it:</p>
<pre>const hummus = function(factor) {
  const ingredient = function(amount, unit, name) {
    let ingredientAmount = amount * factor;
    if (ingredientAmount > 1) {
      unit += "s";
    }
    console.log(`${ingredientAmount} ${unit} ${name}`);
  };
  ingredient(1, "can", "chickpeas");
  ingredient(0.25, "cup", "tahini");
  ingredient(0.25, "cup", "lemon juice");
  ingredient(1, "clove", "garlic");
  ingredient(2, "tablespoon", "olive oil");
  ingredient(0.5, "teaspoon", "cumin");
};</pre>
<p>The code inside the <code>ingredient</code> function can see the <code>factor</code> binding from the outer function. But its local bindings, such as <code>unit</code> or <code>ingredientAmount</code>, are not visible in the outer function.</p>
<p>The set of bindings visible inside a block is determined by the place of that block in the program text. Each local scope can also see all the local scopes that contain it, and all scopes can see the global scope. This approach to binding visibility is called <i>lexical scoping</i>.</p>
<h3>Functions as values</h3>
<p>A function binding usually simply acts as a name for a specific piece of the program. Such a binding is defined once and never changed. This makes it easy to confuse the function and its name.</p>
<p>But the two are different. A function value can do all the things that other values can do—you can use it in arbitrary expressions, not just call it. It is possible to store a function value in a new binding, pass it as an argument to a function, and so on. Similarly, a binding that holds a function is still just a regular binding and can, if not constant, be assigned a new value, like so:</p>
<pre>let launchMissiles = function() {
  missileSystem.launch("now");
};
if (safeMode) {
  launchMissiles = function() {/* do nothing */};
}</pre>
<p>In <a href="/05_higher_order.html">Chapter 5</a>, we will discuss the interesting things that can be done by passing around function values to other functions.</p>
<h3>Declaration notation</h3>
<p>There is a slightly shorter way to create a function binding. When the function keyword is used at the start of a statement, it works differently.</p>
<pre>function square(x) {
  return x * x;
}</pre>
<p>This is a function <i>declaration</i>. The statement defines the binding <i>square</i> and points it at the given function. It is slightly easier to write and doesn’t require a semicolon after the function.</p>
<p>There is one subtlety with this form of function definition.</p>
<pre>console.log("The future says:", future());

function future() {
  return "You'll never have flying cars";
}</pre>
<p>The preceding code works, even though the function is defined below the code that uses it. Function declarations are not part of the regular top-to-bottom flow of control. They are conceptually moved to the top of their scope and can be used by all the code in that scope. This is sometimes useful because it offers the freedom to order code in a way that seems meaningful, without worrying about having to define all functions before they are used.</p>
<h3>Arrow functions</h3>
<p>There’s a third notation for functions, which looks very different from the others. Instead of the <code>function</code> keyword, it uses an arrow (<code>=></code>) made up of an equal sign and a greater-than character (not to be confused with the greater-than-or-equal operator, which is written <code>>=</code>).</p>
<pre>const power = (base, exponent) => {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};</pre>
<p>The arrow comes after the list of parameters and is followed by the function’s body. It expresses something like “this input (the parameters) produces this result (the body)”.</p>
<p>When there is only one parameter name, you can omit the parentheses around the parameter list. If the body is a single expression, rather than a block in braces, that expression will be returned from the function. So, these two definitions of square do the same thing:</p>
<pre>const square1 = (x) => { return x * x; };
const square2 = x => x * x;</pre>
<p>When an arrow function has no parameters at all, its parameter list is just an empty set of parentheses.</p>
<pre>const horn = () => {
  console.log("Toot");
};
</pre>
<p>There’s no deep reason to have both arrow functions and <code>function</code> expressions in the language. Apart from a minor detail, which we’ll discuss in <a href="/06_object.html">Chapter 6</a>, they do the same thing. Arrow functions were added in 2015, mostly to make it possible to write small function expressions in a less verbose way. We’ll be using them a lot in <a href="/05_higher_order.html">Chapter 5</a>.</p>
<h3>The call stack</h3>
<p>The way control flows through functions is somewhat involved. Let’s take a closer look at it. Here is a simple program that makes a few function calls:</p>
<pre>function greet(who) {
  console.log("Hello " + who);
}
greet("Harry");
console.log("Bye");</pre>
<p>The way control flows through functions is somewhat involved. Let’s take a closer look at it. Here is a simple program that makes a few function calls:</p>
<pre>function greet(who) {
  console.log("Hello " + who);
}
greet("Harry");
console.log("Bye");</pre>
<p>A run through this program goes roughly like this: the call to <code>greet</code> causes control to jump to the start of that function (line 2). The function calls <code>console.log</code>, which takes control, does its job, and then returns control to line 2. There it reaches the end of the <code>greet</code> function, so it returns to the place that called it, which is line 4. The line after that calls <code>console.log</code> again. After that returns, the program reaches its end.</p>
<p>We could show the flow of control schematically like this:</p>
<pre>not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function</pre>
<p>Because a function has to jump back to the place that called it when it returns, the computer must remember the context from which the call happened. In one case, <code>console.log</code> has to return to the <code>greet</code> function when it is done. In the other case, it returns to the end of the program.</p>
<p>The place where the computer stores this context is the <i>call stack</i>. Every time a function is called, the current context is stored on top of this stack. When a function returns, it removes the top context from the stack and uses that context to continue execution.</p>
<p>Storing this stack requires space in the computer’s memory. When the stack grows too big, the computer will fail with a message like “out of stack space” or “too much recursion”. The following code illustrates this by asking the computer a really hard question that causes an infinite back-and-forth between two functions. Rather, it <i>would</i> be infinite, if the computer had an infinite stack. As it is, we will run out of space, or “blow the stack”.</p>
<pre>function chicken() {
  return egg();
}
function egg() {
  return chicken();
}
console.log(chicken() + " came first.");
// → ??</pre>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Chap 5 - Higher-Order Functions</title>
</head>
<body>
<h4>Chapter 5</h4>
<h2>Higher-Order Functions</h2>
<blockquote>"Tzu-li and Tzu-ssu were boasting about the size of their latest programs. ‘Two-hundred thousand lines,’ said Tzu-li, ‘not counting comments!’ Tzu-ssu responded, ‘Pssh, mine is almost a <i>million</i> lines already.’ Master Yuan-Ma said, ‘My best program has five hundred lines.’ Hearing this, Tzu-li and Tzu-ssu were enlightened."</blockquote>
<p>-Master Yuan-Ma, <i>The Book of Programming</i></p>
<blockquote>There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies.</blockquote>
<p>-C.A.R. Hoare, <i>1980 ACM Turing Award Lecture</i></p>
<img src="/images/chapter_picture_5.jpg">
<p>A large program is a costly program, and not just because of the time it takes to build. Size almost always involves complexity, and complexity confuses programmers. Confused programmers, in turn, introduce mistakes (<i>bugs</i>) into programs. A large program then provides a lot of space for these bugs to hide, making them hard to find.</p>
<p>Let's briefly go back to the final two example programs in the introduction. The first is self-contained and six lines long.</p>
<pre>let total = 0, count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);</pre>
<p>The second relies on two external functions and is one line long.</p>
<pre>console.log(sum(range(1, 10)));</pre>
<p>Which one is more likely to contain a bug?</p>
<p>If we count the size of the definitions of <code>sum</code> and <code>range</code>, the second program is also big—even bigger than the first. But still, I’d argue that it is more likely to be correct.</p>
<p>It is more likely to be correct because the solution is expressed in a vocabulary that corresponds to the problem being solved. Summing a range of numbers isn’t about loops and counters. It is about ranges and sums.</p>
<p>The definitions of this vocabulary (the functions <code>sum</code> and <code>range</code>) will still involve loops, counters, and other incidental details. But because they are expressing simpler concepts than the program as a whole, they are easier to get right.</p>
<h3>Abstraction</h3>
<p>In the context of programming, these kinds of vocabularies are usually called <i>abstractions</i>. Abstractions hide details and give us the ability to talk about problems at a higher (or more abstract) level.</p>
<p>As an analogy, compare these two recipes for pea soup. The first one goes like this:</p>
<blockquote>"Put 1 cup of dried peas per person into a container. Add water until the peas are well covered. Leave the peas in water for at least 12 hours. Take the peas out of the water and put them in a cooking pan. Add 4 cups of water per person. Cover the pan and keep the peas simmering for two hours. Take half an onion per person. Cut it into pieces with a knife. Add it to the peas. Take a stalk of celery per person. Cut it into pieces with a knife. Add it to the peas. Take a carrot per person. Cut it into pieces. With a knife! Add it to the peas. Cook for 10 more minutes."</blockquote>
<p>And this is the second recipe:</p>
<blockquote>"Per person: 1 cup dried split peas, half a chopped onion, a stalk of celery, and a carrot."</blockquote>
<blockquote>"Soak peas for 12 hours. Simmer for 2 hours in 4 cups of water (per person). Chop and add vegetables. Cook for 10 more minutes."</blockquote>
<p>The second is shorter and easier to interpret. But you do need to understand a few more cooking-related words such as <i>soak</i>, <i>simmer</i>, <i>chop</i>, and, I guess, <i>vegetable</i>.</p>
<p>When programming, we can't rely on all the words we need to be waiting for us in the dictionary. Thus, we might fall into the pattern of the first recipe-work out the precise steps the computer has to perform, one by one, blind to the higher-level concepts that they express.</p>
<p>It is a useful skill, in programming, to notice when you are working at too low a level of abstraction.</p>
<h3>Abstracting repetition</h3>
<p>Plain functions, as we've seen them so far, are a good way to build abstractions. But sometimes they fall short.</p>
<p>It is common for a program to do something a given number of times. You can write a <code>for</code> loop for that, like this:</p>
<pre>for (let i = 0; i < 10; i++) {
  console.log(i);
}</pre>
<p>Can we abstract "doing something N times" as a function? Well, it's easy to write a function that calls <code>console.log</code> <i>N</i> times.</p>
<pre>function repeatLog(n) {
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
}</pre>
<p>But what if we want to do something other than logging the numbers? Since "doing something" can be represented as a function and functions are just values, we can pass our action as a function value.</p>
<pre>function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, console.log);
// → 0
// → 1
// → 2</pre>
<p>We don't have to pass a predefined function to repeat. Often, it is easier to create a function value on the spot instead.</p>
<pre>let labels = [];
repeat(5, i => {
  labels.push(`Unit ${i + 1}`);
});
console.log(labels);
// → ["Unit 1", "Unit 2", "Unit 3", "Unit 4", "Unit 5"]</pre>
<p>This is structured a little like a <code>for</code> loop-it first describes the kind of loop and then provides a body. However, the body is now written as a function value, which is wrapped in the parentheses of the call to <code>repeat</code>. This is why it has to be closed with the closing brace <i>and</i> closing parenthesis. In cases like this example, where the body is a single small expression, you could also omit the braces and write the loop on a single line.</p>
<h3>Higher-order functions</h3>

</body>
</html>